\section{Аналіз існуючих підходів до вирішення задачі}
\subsection{Виділення об'єктів за допомоги віднімання фону}
Віднімання фону - процедура, що за умов нерухомості камери, оцінює зміну кожного пікселя зображення відносно фону, зображення якого було отримане раніше, та отримати в результаті бінарне зображення відмінності поточного зображення від зображення фону.

У вигляді математичних формул це виглядає так:

\begin{equation}
\label{eq:background_substraction}
P[F(t)] = P[I(t)] - P[B]
\end{equation}
де $P[B]$ - зображення фону, $P[I(t)]$ - поточне зображення, $P[F(t)]$ - різниця між поточним зображенням да фоном.

За умови незмінності фону можна працювати з формулою (\ref{eq:background_substraction}).

Для відслідковування рухів динамічних об'єктів також використовується рівняння:
\begin{equation}
\label{eq:frames_difference}
\|P[F(t)] - P[F(t+1)]\| > Treshold
\end{equation}
де $Treshold$ - деяка задана порогова величина.

\begin{figure}[H]
	\includegraphics[width=0.9\linewidth]{task_analysis/img/background_substraction}
	\caption{Ілюстрація роботи простого алгоритма віднімання фону}
\end{figure}

Алгоритм дійсний як для кольорових зображень, так і для зображень у відтінках сірого.

Переваги цього алгоритму у тому, що його достатньо просто реалізувати та він не потребує складних обчислень ( більшість операцій можна векторизувати та паралелізувати що значно прискорює швидкість обробки ). Проте його найбільшим недоліком можна вважати те, що за його допомоги неможливо виділити об'єкт на динамічному фоні, він зпродукує велику кількість областей для подальшого аналізу, який може бути вже не таким тривіальним і система на його базі не зможе працювати в режимі on-line.

\subsection{Відслідковування руки за допомоги контролерів}

У минулих століттях саме цей підхід для роботи з відслідковуванням руки та аналізу жестів був популярним через достатньо прозору та просту програмну реалізацію. За допомоги приблизно 16 сенсорів та вбудованого в рукавицю гіроскопа можна достатньо точно відслідковувати навіть мікрорухи руки.

\begin{figure}[H]
	\includegraphics[width=0.9\linewidth]{task_analysis/img/wired_glove}
	\caption{Cхема рукавиці з сенсорами}
\end{figure}

З точки зору розробників ПЗ простота була у тому, що на вхід вони вже мали позиції усіх ключових точок руки відносно центру ( найчастіше це була лодоня ), та положення центру у просторі. Для аналізу статичних жестів достатньо мати лише відносне положення усіх ключових точок відносно центру. Для аналізу динамічних жестів вже потрібні дані зміни положення руки у просторі.

Також були прототипи контролерів, що містили лише гіроскоп, проте відслідковування позиції у просторі руки як одного об'єкта без данних про позиції ключових точок на пальцях виявився нікому непотрібним і контролели швидко вийшли з виробництва.

Переваги цього підходу до відслідковування руки у просторі в тому, що він дає дуже точні результати та з мінімальною затримкою, проте він має дуже серйозний недоліки - потреба в носінні на собі додаткових незручних приладів та складність підтримки і ремонту таких девайсів.

\subsection{Колірні фільтри для детекції шкіри на зображенні}

Оскільки будь-яке цифрове зображення можливо представити у вигляді:

\begin{equation}
	\label{eq:digital_image_representation}
	M = matrix \: W \times H \times D \: , \: d = dimD
\end{equation}

де $M$ - цифрове зображення, $W$ - ширина зображення, $D$ - розмір колірного простору.
Наприклад для типових колірних просторів RGB, HSV, YCrCb $d = 3$. Для колірного простору градацій сірого $d = 1$.

Колірний простір можна представити так:
\begin{equation}
	\label{eq:color_space_representation}
	( x=(x_1,...,x_d) \in D) \Leftrightarrow ( 0<=x_1<=d_1, ... , 0<=x_d<=d_d )	
\end{equation}
де $D$ - колірний простір, $d_1,...,d_d$ - обмеження координат колірного простору.

Найчастіше зустрічається випадок коли $x_i \in \mathbb{N} \cup \{0\}, d_i = 2^8 , i=1..d$ оскільки це списується в принцип збереження данних у пам'яті ПК.


\subsubsection{Прості колірні фільтри}
Основний принцип роботи простих колірних фільтрів полягає у тому, що емпірічними методами виділяється гіперкуб, що повністю містить у собі всі можливі значення пікселей, що характеризували певний об'єкт.

Формальний вигляд простого фільтра:
\begin{equation}
	\label{eq:simple_color_filter}
	H = {x \in D \mid a_i <= x_i <= b_i, i=1..d}
\end{equation}
	де $a_i,b_i$ - грані гіперкуба.
	
Прості колірні фільтри хороші тим, що дуже прості в реалізації, швидко працюють та є можливість паралелізації обчислень оскільки фільтр обробряє кожен піксель незалежно.

Результатом роботи колірного фільтра $H$ зображення $M$ є бінарна матриця $Q$ :
\begin{equation}
	\label{eq:simple_color_filter_result}
	Q = [q_{ij}], \:\: q_{ij} = ( M[i,j] \in H ), i=1..dimW, j=1..dimH
\end{equation}
Тобто матриця $q_{ij} \in \{0,1\} \forall i,j$ і тому можна достатньо просто записати композицію простих фільтьтрів як поелементні бінарні операції над матрицями. Звісно за допомоги кубів можливо апроксимувати достатньо точно найскладніші фігури, проте це має свої слабкі сторони:
\begin{enumerate}
	\item апроксимація певного тіла кубами в просторі розмірності $d$ достатньо нетривіальна задача з точки зору математики
	\item зі збільшенням точності буде рости кількість простих колірних фільтрів у ланцюгу композицій і це призведе до падіння швидкості роботи
\end{enumerate}

\subsubsection{Гаусівська модель}

\subsubsection{Байесовська модель}
